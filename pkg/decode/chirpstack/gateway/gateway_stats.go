package gateway

import (
	"encoding/hex"
	"strconv"
	"strings"

	"github.com/brocaar/chirpstack-api/go/v3/gw"

	//lint:ignore SA1019 // third-party dependency
	"github.com/golang/protobuf/jsonpb"

	//lint:ignore SA1019 // third-party dependency
	"github.com/golang/protobuf/proto"
	"github.com/thingspect/atlas/pkg/decode"
)

// gatewayStats parses a gateway Stats payload from a []byte according to the
// spec.
func gatewayStats(body []byte) ([]*decode.Point, error) {
	statsMsg := &gw.GatewayStats{}
	if err := proto.Unmarshal(body, statsMsg); err != nil {
		return nil, err
	}

	// Build raw gateway payload for debugging.
	marshaler := &jsonpb.Marshaler{}
	gw, err := marshaler.MarshalToString(statsMsg)
	if err != nil {
		return nil, err
	}
	msgs := []*decode.Point{{Attr: "raw_gateway", Value: gw}}

	// Parse GatewayStats.
	if len(statsMsg.GatewayId) != 0 {
		msgs = append(msgs, &decode.Point{
			Attr: "id", Value: hex.EncodeToString(statsMsg.GatewayId),
		})
	}
	if statsMsg.Ip != "" {
		msgs = append(msgs, &decode.Point{Attr: "ip", Value: statsMsg.Ip})
	}
	if statsMsg.Time != nil {
		msgs = append(msgs, &decode.Point{
			Attr: "time", Value: strconv.FormatInt(statsMsg.Time.Seconds, 10),
		})
	}
	if statsMsg.RxPacketsReceived != 0 {
		msgs = append(msgs, &decode.Point{
			Attr: "rx_received", Value: int32(statsMsg.RxPacketsReceived),
		})
	}
	if statsMsg.RxPacketsReceivedOk != 0 {
		msgs = append(msgs, &decode.Point{
			Attr:  "rx_received_valid",
			Value: int32(statsMsg.RxPacketsReceivedOk),
		})
	}
	if statsMsg.TxPacketsReceived != 0 {
		msgs = append(msgs, &decode.Point{
			Attr: "tx_received", Value: int32(statsMsg.TxPacketsReceived),
		})
	}
	if statsMsg.TxPacketsEmitted != 0 {
		msgs = append(msgs, &decode.Point{
			Attr: "tx_transmitted", Value: int32(statsMsg.TxPacketsEmitted),
		})
	}

	// Use type hinting for metadata generated by atlas-stats. Otherwise, fall
	// back to standard key-value pairs.
	for k, v := range statsMsg.MetaData {
		keys := strings.SplitN(k, "_", 2)

		switch {
		case len(keys) == 2 && keys[0] == "str":
			msgs = append(msgs, &decode.Point{Attr: keys[1], Value: v})
		case len(keys) == 2 && keys[0] == "int":
			intVal, err := strconv.ParseInt(v, 10, 32)
			if err != nil {
				return msgs, err
			}
			msgs = append(msgs,
				&decode.Point{Attr: keys[1], Value: int32(intVal)})
		case len(keys) == 2 && keys[0] == "fl64":
			fl64Val, err := strconv.ParseFloat(v, 64)
			if err != nil {
				return msgs, err
			}
			msgs = append(msgs, &decode.Point{Attr: keys[1], Value: fl64Val})
		default:
			msgs = append(msgs, &decode.Point{Attr: k, Value: v})
		}
	}

	return msgs, nil
}
