// Code generated by MockGen. DO NOT EDIT.
// Source: queuer.go
//
// Generated by this command:
//
//	mockgen -source queuer.go -destination mock_queuer.go -package queue
//

// Package queue is a generated GoMock package.
package queue

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockMessager is a mock of Messager interface.
type MockMessager struct {
	ctrl     *gomock.Controller
	recorder *MockMessagerMockRecorder
}

// MockMessagerMockRecorder is the mock recorder for MockMessager.
type MockMessagerMockRecorder struct {
	mock *MockMessager
}

// NewMockMessager creates a new mock instance.
func NewMockMessager(ctrl *gomock.Controller) *MockMessager {
	mock := &MockMessager{ctrl: ctrl}
	mock.recorder = &MockMessagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockMessager) EXPECT() *MockMessagerMockRecorder {
	return m.recorder
}

// Ack mocks base method.
func (m *MockMessager) Ack() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Ack")
}

// Ack indicates an expected call of Ack.
func (mr *MockMessagerMockRecorder) Ack() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Ack", reflect.TypeOf((*MockMessager)(nil).Ack))
}

// Payload mocks base method.
func (m *MockMessager) Payload() []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Payload")
	ret0, _ := ret[0].([]byte)
	return ret0
}

// Payload indicates an expected call of Payload.
func (mr *MockMessagerMockRecorder) Payload() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Payload", reflect.TypeOf((*MockMessager)(nil).Payload))
}

// Requeue mocks base method.
func (m *MockMessager) Requeue() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Requeue")
}

// Requeue indicates an expected call of Requeue.
func (mr *MockMessagerMockRecorder) Requeue() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Requeue", reflect.TypeOf((*MockMessager)(nil).Requeue))
}

// Topic mocks base method.
func (m *MockMessager) Topic() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Topic")
	ret0, _ := ret[0].(string)
	return ret0
}

// Topic indicates an expected call of Topic.
func (mr *MockMessagerMockRecorder) Topic() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Topic", reflect.TypeOf((*MockMessager)(nil).Topic))
}

// MockSubber is a mock of Subber interface.
type MockSubber struct {
	ctrl     *gomock.Controller
	recorder *MockSubberMockRecorder
}

// MockSubberMockRecorder is the mock recorder for MockSubber.
type MockSubberMockRecorder struct {
	mock *MockSubber
}

// NewMockSubber creates a new mock instance.
func NewMockSubber(ctrl *gomock.Controller) *MockSubber {
	mock := &MockSubber{ctrl: ctrl}
	mock.recorder = &MockSubberMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSubber) EXPECT() *MockSubberMockRecorder {
	return m.recorder
}

// C mocks base method.
func (m *MockSubber) C() <-chan Messager {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "C")
	ret0, _ := ret[0].(<-chan Messager)
	return ret0
}

// C indicates an expected call of C.
func (mr *MockSubberMockRecorder) C() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "C", reflect.TypeOf((*MockSubber)(nil).C))
}

// Unsubscribe mocks base method.
func (m *MockSubber) Unsubscribe() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe.
func (mr *MockSubberMockRecorder) Unsubscribe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockSubber)(nil).Unsubscribe))
}

// MockQueuer is a mock of Queuer interface.
type MockQueuer struct {
	ctrl     *gomock.Controller
	recorder *MockQueuerMockRecorder
}

// MockQueuerMockRecorder is the mock recorder for MockQueuer.
type MockQueuerMockRecorder struct {
	mock *MockQueuer
}

// NewMockQueuer creates a new mock instance.
func NewMockQueuer(ctrl *gomock.Controller) *MockQueuer {
	mock := &MockQueuer{ctrl: ctrl}
	mock.recorder = &MockQueuerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueuer) EXPECT() *MockQueuerMockRecorder {
	return m.recorder
}

// Disconnect mocks base method.
func (m *MockQueuer) Disconnect() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Disconnect")
}

// Disconnect indicates an expected call of Disconnect.
func (mr *MockQueuerMockRecorder) Disconnect() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Disconnect", reflect.TypeOf((*MockQueuer)(nil).Disconnect))
}

// Prime mocks base method.
func (m *MockQueuer) Prime(topic string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Prime", topic)
	ret0, _ := ret[0].(error)
	return ret0
}

// Prime indicates an expected call of Prime.
func (mr *MockQueuerMockRecorder) Prime(topic any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Prime", reflect.TypeOf((*MockQueuer)(nil).Prime), topic)
}

// Publish mocks base method.
func (m *MockQueuer) Publish(topic string, payload []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", topic, payload)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish.
func (mr *MockQueuerMockRecorder) Publish(topic, payload any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockQueuer)(nil).Publish), topic, payload)
}

// Subscribe mocks base method.
func (m *MockQueuer) Subscribe(topic string) (Subber, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", topic)
	ret0, _ := ret[0].(Subber)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe.
func (mr *MockQueuerMockRecorder) Subscribe(topic any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockQueuer)(nil).Subscribe), topic)
}
