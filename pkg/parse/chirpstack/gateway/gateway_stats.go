package gateway

import (
	"encoding/hex"
	"strconv"
	"strings"

	"github.com/brocaar/chirpstack-api/go/v3/gw"

	//lint:ignore SA1019 // third-party dependency
	"github.com/golang/protobuf/jsonpb"

	//lint:ignore SA1019 // third-party dependency
	"github.com/golang/protobuf/proto"
	"github.com/thingspect/atlas/pkg/parse"
)

// gatewayStats parses a gateway Stats payload from a []byte according to the
// spec.
func gatewayStats(body []byte) ([]*parse.Point, error) {
	statsMsg := &gw.GatewayStats{}
	if err := proto.Unmarshal(body, statsMsg); err != nil {
		return nil, err
	}

	// Build raw gateway payload for debugging.
	marshaler := &jsonpb.Marshaler{}
	gw, err := marshaler.MarshalToString(statsMsg)
	if err != nil {
		return nil, err
	}
	msgs := []*parse.Point{{Attr: "raw_gateway", Value: gw}}

	// Parse GatewayStats.
	if len(statsMsg.GatewayId) != 0 {
		msgs = append(msgs, &parse.Point{Attr: "id",
			Value: hex.EncodeToString(statsMsg.GatewayId)})
	}
	if statsMsg.Ip != "" {
		msgs = append(msgs, &parse.Point{Attr: "ip", Value: statsMsg.Ip})
	}
	if statsMsg.Time != nil {
		msgs = append(msgs, &parse.Point{Attr: "time",
			Value: int(statsMsg.Time.Seconds)})
	}
	if statsMsg.RxPacketsReceived != 0 {
		msgs = append(msgs, &parse.Point{Attr: "rx_received",
			Value: int(statsMsg.RxPacketsReceived)})
	}
	if statsMsg.RxPacketsReceivedOk != 0 {
		msgs = append(msgs, &parse.Point{Attr: "rx_received_valid",
			Value: int(statsMsg.RxPacketsReceivedOk)})
	}
	if statsMsg.TxPacketsReceived != 0 {
		msgs = append(msgs, &parse.Point{Attr: "tx_received",
			Value: int(statsMsg.TxPacketsReceived)})
	}
	if statsMsg.TxPacketsEmitted != 0 {
		msgs = append(msgs, &parse.Point{Attr: "tx_transmitted",
			Value: int(statsMsg.TxPacketsEmitted)})
	}

	// Use type hinting for metadata generated by atlas-stats. Otherwise, fall
	// back to standard key-value pairs.
	for k, v := range statsMsg.MetaData {
		keys := strings.SplitN(k, "_", 2)

		switch {
		case len(keys) == 2 && keys[0] == "str":
			msgs = append(msgs, &parse.Point{Attr: keys[1], Value: v})
		case len(keys) == 2 && keys[0] == "int":
			intVal, err := strconv.Atoi(v)
			if err != nil {
				return msgs, err
			}
			msgs = append(msgs, &parse.Point{Attr: keys[1], Value: intVal})
		case len(keys) == 2 && keys[0] == "fl64":
			fl64Val, err := strconv.ParseFloat(v, 64)
			if err != nil {
				return msgs, err
			}
			msgs = append(msgs, &parse.Point{Attr: keys[1], Value: fl64Val})
		default:
			msgs = append(msgs, &parse.Point{Attr: k, Value: v})
		}
	}

	return msgs, nil
}
